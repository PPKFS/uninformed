module Uninformed.ParseTree where

import Uninformed.Prelude
import Uninformed.Lexer
import Data.Tree
import Optics
import Optics.State.Operators
import Text.Megaparsec
import qualified Data.Set as Set
import Data.Char (isUpper)
import Data.Flags
import Uninformed.Vocab

data NodeType = RootNode | HeadingNode Int | BibliographicNode

data NodeAnnotation = UnparsedSentence deriving stock (Ord, Eq)

data Sentence = Sentence [Lexeme] [Lexeme]
data ParseTreeNode = ParseTreeNode
  { _nodeType :: NodeType
  , _nodeAnnotations :: Set.Set NodeAnnotation
  , _nodeSentence :: Sentence
  }

data ExtensionState = NotExt | BeforeBefore | BeforeEnd | AfterEnd deriving stock (Show, Eq)

data ParseTreeState = ParseTreeState
  { _currentFile :: Text
  , _extensionState :: ExtensionState
  , _insideRule :: Bool
  , _insideTable :: Bool
  , _seenBegin :: Bool
  , _skipLevel :: Maybe Int
  , _currentHeadingLevel :: Maybe Int
  , _sentencesParsed :: Int
  , _lastToken :: Maybe Lexeme
  , _startOfParagraph :: Bool
  , _startOfFile :: Bool
  }

makeLenses ''ParseTreeState

type ParseTree = Tree ParseTreeNode

data SentencePos = SentencePos Int Int deriving stock (Ord, Eq)
data ParseTreeError

type Parser = StateT ParseTreeState (Parsec Void [Lexeme])

-- | see if we're parsing a table
tryEnterTableMode :: Parser ()
tryEnterTableMode = lookAhead (do
    _ <- satisfy (\case
        Lexeme (Word v) _ -> matchWord "table" v
        _ -> False)
    insideTable .= True) <|> pass

matchWord
  :: Text
  -> VocabInfo
  -> Bool
matchWord t (VocabInfo _ (Just x) _) = t == x
matchWord t (VocabInfo r Nothing _) = t == r

matchLexeme :: LexemeType -> Lexeme -> Bool
matchLexeme (Word vl@(VocabInfo {})) (Lexeme (Word vi) _) = matchWord vl vi
matchLexeme lt (Lexeme lt' _) = lt == lt'

matchLexemeWord :: Text -> Lexeme -> Bool
matchLexemeWord t = matchLexeme (Word (VocabInfo t Nothing noFlags))

matchWordsOptions :: [Text] -> [Lexeme] -> Bool
matchWordsOptions ts ls = any (\x -> isPrefixOf' matchLexemeWord (words x) ls) ts

buildParseTree :: Parser ParseTree
buildParseTree = do
    tryEnterTableMode
    _ <- catMaybes <$> manyTill (do
        (sentenceWords, sentenceStop) <- manyTill_ (do
            r <- anySingle
            lastToken ?= r
            return r) sentenceBreaker
        sn <- case sentenceWords of
            [] -> return Nothing
            x -> Just <$> uncurry makeSentenceNodes (fixUpSentence x sentenceStop)
        --now we tidy up; namely checking if we need to mark as being in-paragraph
        startOfParagraph .= (_lexemeType sentenceStop `elem` [ParagraphBreak, SourceFileChange])
        sentencesParsed %= (+1)
        return sn
        ) eof
    checkForMissingBeginEnd
    return $ Node (ParseTreeNode RootNode Set.empty (Sentence [] [])) []
    where fixUpSentence ls (Lexeme (JointLexeme a b) _) = (ls <> [a], b)
          fixUpSentence ls x = (ls, x)

-- sentence breaking things

sentenceBreaker :: Parser Lexeme
sentenceBreaker = do
    br <- single' SourceFileChange
        <|> try considerXBreak
        <|> single' ParagraphBreak
        <|> single' (PunctuationToken Period)
        <|> single' (PunctuationToken Semicolon)
        <|> try considerColonDivide
    lastToken .= Nothing
    return br

considerColonDivide :: Parser Lexeme
considerColonDivide = do
    s <- single' (PunctuationToken Colon)
    _ <- lookAhead (satisfy (not . extremeDigit True))
    f <- use lastToken
    if maybe False (extremeDigit False) f then fail "" else return s

considerXBreak :: Parser Lexeme
considerXBreak = do
    -- the spec has the closing " treated as part of the word..
    --so instead, we want to match some punctuation
    --and then a close quote.
    pts <- get
    when (_insideTable pts) (fail "")
    --read punctuation
    st <- satisfy (\l -> isJust $ l ^? lexemeType % _PunctuationToken)
    --read quote close
    qc <- single' QuoteEnd
    --next word begins with a capital
    nw <- lookAhead
        (satisfy (\l -> isJust $ l ^? lexemeType % _Word))
    when (extremeOfWord (not . isUpper) True nw) (fail "")
    -- so return the punctuation, combined with the quote end
    return (st & lexemeType .~ JointLexeme st qc)

-- we skip if the skip flag is higher than the heading level
-- and not out of an extension
areSkipping :: Parser Bool
areSkipping = do
    s <- get
    return ((_extensionState s /= AfterEnd) &&
        fromMaybe False (liftA2 (>=) (_skipLevel s) (_currentHeadingLevel s)))

updateSkipping :: Parser ()
updateSkipping = error "not implemented"

-- given a fixed sentence, now make a (or in rare cases 2) node.
makeSentenceNodes
  :: [Lexeme]
  -> Lexeme
  -> Parser [ParseTreeNode]
makeSentenceNodes (x:xs) (Lexeme SourceFileChange _) =
    fail $ "Have found a source file change with " <> show (x:xs) <> "before it; did you forget a punctuation mark?"
makeSentenceNodes [] l@(Lexeme SourceFileChange _) = skipLevel .= Nothing >> ((:[]) <$> makeHeading [l] l 0)
--if we've somehow let an empty sentence sneak through
makeSentenceNodes [] _ = return []
makeSentenceNodes sentence@(s:ss) stop = do
    headingLevel <- isHeadingSentence s
    setHeadingLevel $ fromMaybe 0 headingLevel
    checkForBeginsOrEnds sentence
    --if we're skipping, then we...skip
    --else if it's a heading, make a heading
    --else else we make nodes
    ifM areSkipping (return []) (do
        case headingLevel of
            Just x -> (do
                --there's some header checking (4/sent.14-15) but I cbf
                --also I currently ignore the sentence end out of laziness
                h <- makeHeading sentence stop x
                updateSkipping
                return [h]
                )
            Nothing -> (do
                s' <- get
                if _sentencesParsed s' == 1
                        && checkMeaningCodes s (isQuotedText .+. isQuotedTextWithSubs)
                then
                    (:[]) <$> makeNode sentence stop BibliographicNode
                else
                    acceptNodes (s :| ss) stop))

acceptNodes
  :: NonEmpty Lexeme -- ^ sentence
  -> Lexeme -- ^ stop char
  -> Parser [ParseTreeNode]
acceptNodes sentence stop = do
    caseM (map (flip ($ sentence) stop) [
        -- see if we need to split a sentence
        splitCommaSentences
        --see if we need to make a rule routine
        , convertRulePreamble
        --make a command node if in rule mode
        , makeCommandNode
        --IGNORE asterisk/trace mode
        --make a table node
        , makeTableNode
        --make an equation node
        , makeEquationNode
        --make an include node
        , makeIncludeNode
        --IGNORE inform6
        --make a begins/ends node
        , makeBeginsEndsNode
        ]) regularSentenceNode

fail' :: MaybeT m a
fail' = fail ""

splitCommaSentences
  :: NonEmpty Lexeme
  -> Lexeme
  -> MaybeT Parser [ParseTreeNode]
splitCommaSentences sentence (Lexeme stop _) = do
    whenM (gets _insideRule) fail'
    unless (stop == PunctuationToken Period || stop == PunctuationToken Colon) fail'
    unless (matchWordsOptions
        ["instead of", "every turn", "before", "after", "when" ] (toList sentence) ) fail'
    --first we look for the 'or'; if there's an or
    --then we split on the end of the serial list
    --otherwise, we split from the start
    let splitList = splitOnIntermediateWord "or" sentence
        earliestComma = maybe sentence snd splitList
        commaPos = splitOnIntermediate
    return []

splitOnIntermediate
  :: LexemeType
  -> NonEmpty Lexeme
  -> Maybe ([Lexeme], NonEmpty Lexeme)
splitOnIntermediate t ls = case break (matchLexeme t) (toList ls) of
    (_, []) -> Nothing
    (a, b:bs) -> Just (a, b:|bs)

splitOnIntermediateWord
  :: Text
  -> NonEmpty Lexeme
  -> Maybe ([Lexeme], NonEmpty Lexeme)
splitOnIntermediateWord t = splitOnIntermediate (Word (VocabInfo t Nothing noFlags))
checkForMissingBeginEnd :: Parser ()
checkForMissingBeginEnd = error "not implemented"

checkMeaningCodes :: Lexeme -> MeaningCodes -> Bool
checkMeaningCodes = error "not implemented"



checkForBeginsOrEnds :: [Lexeme] -> Parser ()
checkForBeginsOrEnds l = do
    v <- gets _extensionState
    let extN | matchWordsOptions ["begins", "begins here"] l = Just BeforeEnd
             | matchWordsOptions ["ends", "ends here"] l = Just AfterEnd
             | otherwise = Nothing
    when (extN == Just BeforeEnd && v == BeforeEnd) (fail "Found multiple begins here statements")
    when (extN == Just BeforeEnd && v == AfterEnd) (fail "Found begins here after an ends here statement")
    when (extN == Just AfterEnd && v == BeforeBefore) (fail "Found ends here before begins here statement")
    when (extN == Just AfterEnd && v == AfterEnd) (fail "Found multiple ends here statements")
    whenJust extN (extensionState .=)
    return ()

setHeadingLevel :: Int -> Parser ()
setHeadingLevel = (currentHeadingLevel ?=)

isHeadingSentence :: Lexeme -> Parser (Maybe Int)
isHeadingSentence (Lexeme (Word lt) _) = do
            v <- gets _startOfParagraph
            let h | matchWord "volume" lt = Just 1
                  | matchWord "book" lt = Just 2
                  | matchWord "part" lt = Just 3
                  | matchWord "chapter" lt = Just 4
                  | matchWord "section" lt = Just 5
                  | otherwise = Nothing
            if not v then return Nothing else return h
isHeadingSentence _ = return Nothing

makeNode :: [Lexeme] -> Lexeme -> NodeType -> Parser ParseTreeNode
makeNode lex e nt = return ParseTreeNode
        { _nodeType = nt
        , _nodeAnnotations = fromList [UnparsedSentence]
        , _nodeSentence = Sentence lex [e]
        }

makeHeading :: [Lexeme] -> Lexeme -> Int -> Parser ParseTreeNode
makeHeading lex e lvl = do
    --declare heading
    currentHeadingLevel .= Just lvl
    makeNode lex e (HeadingNode lvl)